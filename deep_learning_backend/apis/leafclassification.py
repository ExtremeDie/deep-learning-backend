# -*- coding: utf-8 -*-
"""LeafClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1djaXXRnAJwtjezCgMTvV7oeVCFRmn3sG
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import torchvision
import torchvision.datasets as dset
import torchvision.transforms as transforms
from torch.utils.data import DataLoader, Dataset
import matplotlib.pyplot as plt
import torchvision.utils
import numpy as np
import random
from PIL import Image
import torch
from torch.autograd import Variable
import PIL.ImageOps
import torch.nn as nn
from torch import optim
import torch.nn.functional as F
import torchvision.models as models
import os
import random
from torch.optim import lr_scheduler

print(os.getcwd())
# root_path = os.path.join(os.getcwd(), 'deep_learning_backend') # windows
root_path = "" # linux

plant_names = [
    "aesculus_chinensis",
    "acer_platanoides",
    "acer_palmatum",
    "alnus_incana",
    "cercis_chinensis",
    "cedrus_deodara_g_don",
    "berberis_anhweiensis_ahrendt",
    "chimonanthus_praecox_l",
    "acer_buergerianum_miq",
    "betula_pubescens",
    "kalopanax_septemlobus_koidz",
    "fagus_sylvatica",
    "citrus_reticulata_blanco",
    "ginkgo_biloba_l",
    "cinnamomum_camphora_j_presl",
    "cinnamomum_japonicum_sieb",
    "koelreuteria_paniculata_laxmi",
    "ilex_macrocarpa_oliv",
    "indigofera_tinctoria_l",
    "lagerstroemia_indica_pers",
    "pittosporum_tobira_aitf",
    "osmanthus_fragrans_lour",
    "phyllostachys_edulis",
    "magnolia_grandiflora_l",
    "nerium_oleander_l",
    "phoebe_nanmu_gamble",
    "liriodendron_chinense_sarg",
    "mahonia_bealei_carr",
    "ligustrum_lucidum_ait_f",
    "manglietia_fordiana_oliv",
    "prunus_persica_batsch",
    "salix_alba",
    "populus",
    "prunus_serrulata_lindl_var_lannesiana_auct",
    "populus_canadensis_moench",
    "podocarpus_macrophyllus_sweet",
    "populus_tremula",
    "salix_sinerea",
    "quercus",
    "salix_aurita",
    "tilia",
    "ulmus_carpinifolia",
    "tonna_sinensis",
    "sorbus_aucuparia",
    "viburnum_awabuki_k_koch",
    "sorbus_intermedia",
    "ulmus_glabra",
    "rhamnus_cathartica",
    "olea_europaea",
    "albizia_julibrissin",
    "arbutus_unedo",
    "syringa_vulgaris",
    "melia_azedarach",
    "laburnum_anagyroides",
    "acer_monspessulanum",
    "fraxinus_ornus",
    "corylus_avellana",
    "juglans_nigra",
    "fraxinus_angustifolia",
    "rhamnus_alaternus",
    "quercus_petraea",
    "malus_sylvestris",
    "quercus_pubescens",
    "acer_campestre",
    "vitex_agnus_castus",
    "cotinus_coggygria",
    "viburnum_tinus",
    "pistacia_terebinthus",
    "carpinus_betulus",
    "acer_negundo",
    "ficus_carica",
    "prunus_serotina",
    "aesculus_hippocastanum",
    "prunus_mahaleb",
    "paliurus_spina_christi",
    "salix_caprea",
    "rhus_typhina",
    "viburnum_lantana",
    "sophora_japonica",
    "acer_opalus",
    "tilia_cordata",
    "platanus_x",
    "prunus_spinosa",
    "crataegus_azarolus",
    "quercus_ilex",
    "cornus_mas",
    "sorbus_torminalis",
    "ligustrum_vulgare",
    "fraxinus_excelsior",
    "celtis_australis",
    "robinia_pseudoacacia",
    "gleditsia_triacanthos",
    "sorbus_aria",
    "eriobotrya_japonica",
    "castanea_sativa",
    "acer_pseudoplatanus",
    "ailanthus_altissima",
    "sambucus_nigra",
    "sorbus_domestica",
    "quercus_coccifera",
    "alnus_glutinosa",
    "pistacia_lentiscus",
    "ilex_aquifolium",
    "punica_granatum",
    "phillyrea_angustifolia",
    "diospyros_kaki",
    "betula_pendula",
    "cercis_siliquastrum",
    "broussonetia_papyrifera",
    "laurus_nobilis",
    "juglans_regia",
    "crataegus_monogyna",
]

def set_seed(seed):
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
    np.random.seed(seed)
    random.seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)


set_seed(1)


def imshow(img, text=None, should_save=False):
    npimg = img.numpy()
    plt.axis("off")
    if text:
        plt.text(75,
                 8,
                 text,
                 style='italic',
                 fontweight='bold',
                 bbox={
                     'facecolor': 'white',
                     'alpha': 0.8,
                     'pad': 10
                 })
    plt.imshow(np.transpose(npimg, (1, 2, 0)))
    plt.show()

def build_network(model_name, pretrained=True):
  out_features = 112
  if model_name == "resnet18" or model_name == "resnet152":
    model = models.resnet18(pretrained) if model_name == "resnet18" else models.resnet152(pretrained)
    in_features = model.fc.in_features
    model.fc = nn.Linear(in_features, out_features)
    if not pretrained:
      for name, param in model.named_parameters():
        if not any(name.startswith(ext) for ext in ['layer3', 'layer4', 'fc']):
          param.requires_grad = False
  return model

transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

model_path = os.path.join(root_path, 'leaf_classifier_model.pth')
print(model_path)
if torch.cuda.is_available():
    net = build_network(model_name="resnet152", pretrained=True).cuda()
    net.load_state_dict(torch.load(model_path))
else:
    net = build_network(model_name="resnet152", pretrained=True)
    net.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))

def predict(img):
    img = transform(img)
    # imshow(img)
    if torch.cuda.is_available():
        img = img.unsqueeze(0).cuda()
    else:
        img = img.unsqueeze(0)
    out = net(img)
    probs = torch.softmax(out, dim=1)
    idx = probs.argmax(dim=1).item()

    return plant_names[idx]
